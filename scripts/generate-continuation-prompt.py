#!/usr/bin/env python3
"""
Generate continuation prompt for new session

Creates continuation-prompt.txt with:
- Project summary
- Top files modified
- Context files to read
- Estimated token cost
- Related pending work from BACKLOG
"""

import json
import sys
from datetime import datetime
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent


def parse_project_file(project_file_path):
    """Parse project markdown file"""
    with open(project_file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    metadata = {}
    lines = content.split('\n')

    # Extract title
    for line in lines:
        if line.startswith('# '):
            metadata['title'] = line.lstrip('#').strip()
            break

    # Extract description
    desc_start = False
    description_lines = []
    for line in lines:
        if line.startswith('## Description'):
            desc_start = True
            continue
        if desc_start:
            if line.startswith('##'):
                break
            if line.strip():
                description_lines.append(line.strip())

    metadata['description'] = ' '.join(description_lines[:2])  # First 2 lines

    # Extract files modified
    files = set()
    for line in lines:
        if 'Files:' in line or 'Files modified:' in line:
            files_part = line.split(':', 1)[1] if ':' in line else ''
            for f in files_part.split(','):
                if f.strip():
                    files.add(f.strip())

    metadata['files'] = sorted(files)

    return metadata


def get_project_id(project_file_path):
    """Extract project ID from file name"""
    filename = Path(project_file_path).stem
    # Remove .project suffix if exists
    if filename.endswith('.project'):
        filename = filename[:-8]
    return filename


def get_related_work():
    """Get related pending work from BACKLOG.md"""
    backlog_file = PROJECT_ROOT / ".claude" / "BACKLOG.md"

    if not backlog_file.exists():
        return []

    with open(backlog_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # Find Active tasks
    active_tasks = []
    in_active_section = False

    for line in lines:
        if '## Active' in line:
            in_active_section = True
            continue
        if in_active_section:
            if line.startswith('##'):
                break
            if line.strip().startswith('-'):
                task = line.strip().lstrip('- ').strip()
                active_tasks.append(task)

    return active_tasks[:5]  # Top 5 active tasks


def estimate_context_tokens(project_data):
    """Estimate tokens needed to resume work"""
    base_tokens = 400  # CONTEXT_SUMMARY.md
    project_tokens = 200  # project file itself
    completion_summary = 300  # completion-summary.md

    # Add per-file estimate (assume 100 tokens avg for context)
    file_count = len(project_data.get('files', []))
    file_tokens = min(file_count * 50, 1000)  # Cap at 1000

    total = base_tokens + project_tokens + completion_summary + file_tokens
    return round(total, -2)  # Round to nearest 100


def generate_prompt(project_data, project_id):
    """Generate continuation prompt"""
    project_name = project_data.get('title', 'Unknown Project')
    description = project_data.get('description', 'No description available')
    files = project_data.get('files', [])
    related = get_related_work()
    token_estimate = estimate_context_tokens(project_data)

    # Get top 10 files
    top_files = files[:10]

    prompt = f"""Continue work from "{project_name}" project:

This project completed implementing {description}

Files modified:
"""

    for file_path in top_files:
        # Determine if new or enhanced
        indicator = "(new)" if any(x in file_path for x in ['new', 'New']) else "(enhanced)"
        prompt += f"- {file_path} {indicator}\n"

    if len(files) > 10:
        prompt += f"... and {len(files) - 10} more files\n"

    prompt += f"""

To resume related work in a NEW SESSION:

1. Read the project completion summary:
   docs/projects/{project_id}/completion-summary.md

2. Check for follow-up tasks in .claude/BACKLOG.md

3. If extending this work, create a new phase or project:
   /project start "<follow-up-name>"

4. Context files to read first:
   - .claude/context/CONTEXT_SUMMARY.md (~400 tokens)
   - docs/projects/{project_id}/<project-file>.project.md

"""

    if related:
        prompt += "5. Related pending work:\n"
        for task in related:
            prompt += f"   - {task}\n"
        prompt += "\n"

    prompt += f"""Total context needed: ~{token_estimate} tokens (read artifacts above)

---
This prompt auto-generated by /project complete on {datetime.now().isoformat() + 'Z'}
"""

    return prompt


def main():
    if len(sys.argv) < 2:
        print("Usage: python generate-continuation-prompt.py <project-file-path>")
        sys.exit(1)

    project_file = Path(sys.argv[1])

    if not project_file.exists():
        print(f"Error: Project file not found: {project_file}")
        sys.exit(1)

    # Parse project file
    project_data = parse_project_file(project_file)
    project_id = get_project_id(project_file)

    # Generate prompt
    prompt = generate_prompt(project_data, project_id)

    # Output to stdout
    print(prompt)


if __name__ == '__main__':
    main()
